[
  {
    "question": "Why can buffer overflows occur in Java applications using JNI, despite Java's built-in memory safety?",
    "options": {
      "A": "Java's garbage collector has bugs related to native memory.",
      "B": "JNI allows calling native code (like C/C++) which runs outside JVM's direct memory management and may contain unsafe memory operations.",
      "C": "The System.loadLibrary call inherently corrupts memory.",
      "D": "All Java classes like String and ArrayList become unsafe when used with JNI."
    },
    "answer": "B"
  },
  {
    "question": "In the lab's initial vulnerable C code (NativeCLib.c), which function was primarily responsible for causing the buffer overflow?",
    "options": {
      "A": "printf",
      "B": "GetStringUTFChars",
      "C": "ReleaseStringUTFChars",
      "D": "strcpy"
    },
    "answer": "D"
  },
  {
    "question": "How did the ArrayListNativeJavaLib and StringBuilderNativeJavaLib examples prevent the buffer overflow demonstrated earlier in the lab?",
    "options": {
      "A": "They used a special, secure version of the native library.",
      "B": "They automatically resized the native C buffer using JNI.",
      "C": "They checked the input data size in Java *before* calling the native method, avoiding the call if the input was too large.",
      "D": "They converted the String to a ByteBuffer before calling the native method."
    },
    "answer": "C"
  },
  {
    "question": "How does using ByteBuffer (as shown in ByteBufferNativeJavaLib) help prevent buffer overflows when interacting with *safely written* JNI code?",
    "options": {
      "A": "ByteBuffer automatically encrypts data passed to native code.",
      "B": "The native code can query the ByteBuffer object (using JNI functions) to get its actual size/limit and respect those boundaries during access.",
      "C": "ByteBuffer prevents the native C code from using pointers.",
      "D": "Using ByteBuffer forces the JVM to perform extra bounds checks inside the native code."
    },
    "answer": "B"
  },
  {
    "question": "How does `ValidatingObjectInputStream` in `SecureDeserialization.java` prevent the exploit?",
    "options": {
      "A": "By encrypting the serialized data stream.",
      "B": "By automatically deleting any file named 'payload.ser'.",
      "C": "By checking the class being deserialized against a whitelist (using `accept()`) and throwing an exception if it's not allowed.",
      "D": "By limiting the size of the file that can be deserialized."
    },
    "answer": "C"
  },
  {
    "question": "What is the primary security risk associated with insecure deserialization vulnerabilities?",
    "options": {
      "A": "Denial of Service (DoS) by consuming excessive memory.",
      "B": "Disclosure of sensitive information stored within the object.",
      "C": "Arbitrary Code Execution (ACE) by processing malicious objects.",
      "D": "Cross-Site Scripting (XSS) through serialized HTML content."
    },
    "answer": "C"
  }
  {
    "question": "In the vulnerable `InsecureDeserialization.java` code, which specific method call represents the core point of the vulnerability?",
    "options": {
      "A": "new FileInputStream(filename)",
      "B": "ois.readObject()",
      "C": "System.out.println()",
      "D": "new ObjectInputStream(fis)"
    },
    "answer": "B"
  }
]
